import time

import pytest

from framework.basic_fiber import FiberTest


class TestUpdateChannel(FiberTest):
    """
    - channel_id
        1. channel_id 不存在
        2. channel_id 存在
    - enabled
        1. enable 不填
        2. enable 为true
        3. enable 为 false
    - tlc_expiry_delta
        1. 不填
        2. 0
        3. over flow
        4. 修改为正常值
    - tlc_minimum_value
        1. 不填
        2. 修改为正常值
        3. overflow
        4. 0
    - tlc_fee_proportional_millionths
        1. 不填
        2. 修改为正常值
        3. overflow
        4. 0
        5. 特别大

    - 在 channel 状态修改
        - 处于open pending 状态调用 update_channel
        - 处于交易状态调用 update_channel
        - 处于关闭状态调用 update_channel
    - 私有channel
    - 对端节点不在线时
        - 调用 update_channel
    - 调用中途 节点关闭
        - 对方节点关闭
        - 我方节点关闭


    修改后
    1. 检查list_channel 状态是否正确
    2. 发送交易看是否修改成功
    2. 检查graph_channel 是否修改
        - 检查 a,b,c 3个节点 是否更新正确
    """

    def test_01(self):
        """
        1. channel_id 存在
        2. enable 为true
        3. tlc_minimum_value 为正常值
        4. tlc_maximum_value 为正常值
        5. tlc_fee_proportional_millionths 为正常值
        Returns:
        """
        update_channel_param = {
            "enabled": True,
            "tlc_minimum_value": hex(100),
            "tlc_fee_proportional_millionths": hex(1000),
        }

        # 1. fiber3(200) open_channel fiber1(0)
        account3_private = self.generate_account(1000)
        self.fiber3 = self.start_new_fiber(account3_private)
        self.fiber3.connect_peer(self.fiber1)
        time.sleep(1)
        self.fiber3.get_client().open_channel(
            {
                "peer_id": self.fiber1.get_peer_id(),
                "funding_amount": hex(200 * 100000000),
                "public": True,
            }
        )
        self.wait_for_channel_state(
            self.fiber3.get_client(), self.fiber1.get_peer_id(), "CHANNEL_READY", 120
        )

        # 2. fiber1(200) open_channel fiber2(0)
        temporary_channel_id = self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(200 * 100000000),
                "public": True,
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY", 120
        )
        # 3. fiber1 send_payment fiber 2 1 ckb
        invoice_balance = hex(1 * 100000000)
        payment_preimage = self.generate_random_preimage()
        invoice = self.fiber2.get_client().new_invoice(
            {
                "amount": invoice_balance,
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": payment_preimage,
            }
        )
        time.sleep(1)
        before_channel = self.fiber1.get_client().list_channels({})
        payment = self.fiber1.get_client().send_payment(
            {
                "invoice": invoice["invoice_address"],
            }
        )
        self.wait_payment_state(self.fiber1, payment["payment_hash"], "Success", 120)
        after_channel = self.fiber1.get_client().list_channels({})
        assert int(before_channel["channels"][0]["local_balance"], 16) - int(
            after_channel["channels"][0]["local_balance"], 16
        ) == int(invoice_balance, 16)
        channel = self.fiber3.get_client().list_channels({})
        channel2 = self.fiber2.get_client().list_channels({})

        # 4. fiber2 call  update_channel (id,tlc_fee_proportional_millionths)
        tlc_fee_proportional_millionths = 2000

        update_channel_param["channel_id"] = channel2["channels"][0]["channel_id"]
        channels = self.fiber1.get_client().update_channel(update_channel_param)
        time.sleep(1)
        # 1. todo check enable

        # 2. check tlc_minimum_value   = fee + amount
        invoice_balance = hex(int(update_channel_param["tlc_minimum_value"], 16) - 10)
        payment_preimage = self.generate_random_preimage()
        invoice = self.fiber2.get_client().new_invoice(
            {
                "amount": invoice_balance,
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": payment_preimage,
            }
        )
        time.sleep(1)
        with pytest.raises(Exception) as exc_info:
            payment = self.fiber3.get_client().send_payment(
                {
                    "invoice": invoice["invoice_address"],
                }
            )

        expected_error_message = "Failed to build route"
        assert expected_error_message in exc_info.value.args[0], (
            f"Expected substring '{expected_error_message}' "
            f"not found in actual string '{exc_info.value.args[0]}'"
        )

        # 4. todo check tlc_fee_proportional_millionths
        graph_channels = self.fiber3.get_client().graph_channels()

        # 5. todo check tlc_expiry_delta

    # @pytest.mark.skip("https://github.com/nervosnetwork/fiber/issues/353")
    def test_m(self):
        router_length = 2
        for i in range(router_length):
            account_private = self.generate_account(1000)
            fiber = self.start_new_fiber(account_private)
            fiber.connect_peer(self.fiber1)
            fiber.connect_peer(self.fiber2)
        for i in range(len(self.fibers) - 1):
            linked_fiber = self.fibers[(i + 1) % len(self.fibers)]
            current_fiber = self.fibers[i]
            linked_fiber.connect_peer(current_fiber)
            time.sleep(1)
            # open channel
            current_fiber.get_client().open_channel(
                {
                    "peer_id": linked_fiber.get_peer_id(),
                    "funding_amount": hex(500 * 100000000),
                    "public": True,
                }
            )
            # // AWAITING_TX_SIGNATURES
            self.wait_for_channel_state(
                current_fiber.get_client(), linked_fiber.get_peer_id(), "CHANNEL_READY"
            )
            for i in range(100):
                linked_fiber.get_client().update_channel(
                    {
                        "channel_id": current_fiber.get_client().list_channels({})[
                            "channels"
                        ][0]["channel_id"],
                        "tlc_fee_proportional_millionths": hex(2000 + i),
                    }
                )
                time.sleep(0.02)
            self.wait_for_channel_state(
                current_fiber.get_client(), linked_fiber.get_peer_id(), "CHANNEL_READY"
            )
        time.sleep(1)
        pub_key = self.fibers[-1].get_client().node_info()["node_id"]
        payment = (
            self.fibers[0]
            .get_client()
            .send_payment(
                {
                    "target_pubkey": pub_key,
                    "amount": hex(10 * 100000000),
                    "keysend": True,
                }
            )
        )
        self.wait_payment_state(self.fibers[0], payment["payment_hash"], "Success")
