import time

import pytest

from framework.basic_fiber import FiberTest


class WithTx(FiberTest):

    #    @pytest.mark.skip("https://github.com/nervosnetwork/fiber/issues/503")
    def test_send_force_shutdown_with_tx(self):
        temporary_channel_id = self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(200 * 100000000),
                "public": True,
                # "tlc_fee_proportional_millionths": "0x4B0",
            }
        )
        time.sleep(1)
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY", 120
        )
        payment = self.fiber1.get_client().send_payment(
            {
                "amount": hex(100 * 100000000),
                "target_pubkey": self.fiber2.get_client().node_info()["node_id"],
                "keysend": True,
            }
        )
        self.wait_payment_state(self.fiber1, payment["payment_hash"])

        amount = 10 * 100000000
        invoice = self.fiber2.get_client().new_invoice(
            {
                "amount": hex(amount),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": self.generate_random_preimage(),
                "hash_algorithm": "sha256",
            }
        )
        time.sleep(1)

        channels = self.fiber1.get_client().list_channels(
            {"peer_id": self.fiber2.get_peer_id()}
        )
        N1N2_CHANNEL_ID = channels["channels"][0]["channel_id"]

        # 5. Send payment using the created invoice
        payment = self.fiber1.get_client().send_payment(
            {
                "invoice": invoice["invoice_address"],
            }
        )
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": N1N2_CHANNEL_ID,
                "force": True,
            }
        )
        channels = self.fiber1.get_client().list_channels({"include_closed": True})
        self.fiber1.get_client().get_payment({"payment_hash": payment["payment_hash"]})
        time.sleep(5)
        self.fiber2.get_client().send_payment(
            {
                "amount": hex(1),
                "target_pubkey": self.fiber1.get_client().node_info()["node_id"],
                "keysend": True,
            }
        )
        time.sleep(3)
        self.node.getClient().generate_epochs("0xf")
        tx_hash = self.wait_and_check_tx_pool_fee(1000, False, 600)
        message = self.get_tx_message(tx_hash)
        self.get_fibers_balance_message()
        print("message:", message)
        assert {
            "args": "0x470dcdc5e44064909650113a274b3b36aecb6dc7",
            "capacity": 16199999545,
        } in message["output_cells"]

        # todo
        try:
            payment_hash = self.send_payment(self.fiber2, self.fiber1, 1, False)
            self.wait_payment_state(self.fiber2, payment_hash, "Failed")
        except Exception as e:
            print(f"Expected failure when sending payment after force shutdown: {e}")
            assert "no path found" in f"{e}"

    def test_receive_force_shutdown_with_tx(self):
        temporary_channel_id = self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(200 * 100000000),
                "public": True,
                # "tlc_fee_proportional_millionths": "0x4B0",
            }
        )
        time.sleep(1)
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY", 120
        )
        payment = self.fiber1.get_client().send_payment(
            {
                "amount": hex(100 * 100000000),
                "target_pubkey": self.fiber2.get_client().node_info()["node_id"],
                "keysend": True,
            }
        )
        self.wait_payment_state(self.fiber1, payment["payment_hash"])

        amount = 10 * 100000000
        invoice = self.fiber2.get_client().new_invoice(
            {
                "amount": hex(amount),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": self.generate_random_preimage(),
                "hash_algorithm": "sha256",
            }
        )
        time.sleep(1)

        channels = self.fiber1.get_client().list_channels(
            {"peer_id": self.fiber2.get_peer_id()}
        )
        N1N2_CHANNEL_ID = channels["channels"][0]["channel_id"]

        # 5. Send payment using the created invoice
        payment = self.fiber1.get_client().send_payment(
            {
                "invoice": invoice["invoice_address"],
            }
        )
        self.fiber2.get_client().shutdown_channel(
            {
                "channel_id": N1N2_CHANNEL_ID,
                "force": True,
            }
        )

        self.fiber1.get_client().get_payment({"payment_hash": payment["payment_hash"]})
        time.sleep(5)
        self.node.getClient().generate_epochs("0xf")
        tx_hash = self.wait_and_check_tx_pool_fee(1000, False, 600)
        message = self.get_tx_message(tx_hash)
        assert {
            "args": "0x470dcdc5e44064909650113a274b3b36aecb6dc7",
            "capacity": 16199999545,
        } in message["output_cells"]
        self.get_fibers_balance_message()
        print("message:", message)
        assert {
            "args": "0x470dcdc5e44064909650113a274b3b36aecb6dc7",
            "capacity": 16199999545,
        } in message["output_cells"]
