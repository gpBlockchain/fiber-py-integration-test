# import time
#
# from framework.basic_fiber import FiberTest
#
#
# class TestDisconnect(FiberTest):
#
#     def test_0000(self):
#         self.fiber1.connect_peer(self.fiber2)
#         self.fiber1.get_client().list_peers()
#
#     def test_bb12323(self):
#         self.get_fibers_balance_message()
#         pass
#
#     def test_bbb12(self):
#         self.get_fibers_balance_message()
#         # self.send_payment(self.fiber1,self.fiber2,1)
#         self.fiber1.get_client().list_channels({"peer_id": self.fiber2.get_peer_id()})
#
#     def test_key_send(self):
#
#         # self.open_channel(self.fibers[0], self.fibers[1], 1000 * 100000000, 1)
#
#         # a-b 压测 断开a-b
#         for j in range(20):
#             payment_hashs = []
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fiber1, self.fiber2, 1 * 100000000, False
#                 )
#
#                 payment_hashs.append(payment_hash)
#             self.fiber1.get_client().disconnect_peer(
#                 {"peer_id": self.fiber2.get_peer_id()}
#             )
#             # self.fiber1.stop()
#             # self.fiber2.stop()
#             time.sleep(1)
#             # self.fiber1.start()
#             # self.fiber2.start()
#             before_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             assert before_fiber1_balance["ckb"]["offered_tlc_balance"] > 0
#
#             self.fiber1.connect_peer(self.fiber2)
#             for payment_hash in payment_hashs:
#                 self.wait_payment_finished(self.fiber1, payment_hash)
#             self.wait_fibers_pending_tlc_eq0(self.fiber1)
#             # after_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             # print("before_fiber1_balance:", before_fiber1_balance)
#             # print("after_fiber1_balance:", after_fiber1_balance)
#             # assert after_fiber1_balance["ckb"]["offered_tlc_balance"] == 0
#             self.send_payment(self.fiber1, self.fiber2, 1)
#
#     debug = True
#     def test_invoice_send(self):
#         self.open_channel(self.fibers[0], self.fibers[1], 1000 * 100000000, 1)
#         # a-b 压测 断开a-b
#         for j in range(2):
#             payment_hashs = []
#             invoices = []
#             for i in range(30):
#                 invoice = self.fiber2.get_client().new_invoice(
#                     {
#                         "amount": hex(1),
#                         "currency": "Fibd",
#                         "description": "test invoice generated by node2",
#                         "expiry": "0xe10",
#                         "final_cltv": "0x28",
#                         "payment_preimage": self.generate_random_preimage(),
#                         "hash_algorithm": "sha256",
#                     }
#                 )
#                 invoices.append(invoice)
#             for i in range(30):
#                 # payment_hash = self.send_payment(
#                 #     self.fiber1, self.fiber2, 1 * 100000000, False
#                 # )
#
#                 payment = self.fiber1.get_client().send_payment(
#                     {
#                         "invoice": invoices[i]["invoice_address"],
#                     }
#                 )
#                 payment_hashs.append(payment["payment_hash"])
#             self.fiber1.get_client().disconnect_peer(
#                 {"peer_id": self.fiber2.get_peer_id()}
#             )
#             # self.fiber1.stop()
#             # self.fiber2.stop()
#             time.sleep(10)
#             # self.fiber1.start()
#             # self.fiber2.start()
#             before_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             assert before_fiber1_balance["ckb"]["offered_tlc_balance"] > 0
#
#             self.fiber1.connect_peer(self.fiber2)
#             for payment_hash in payment_hashs:
#                 self.wait_payment_finished(self.fiber1, payment_hash)
#             self.wait_fibers_pending_tlc_eq0(self.fiber1)
#             after_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             # print("before_fiber1_balance:", before_fiber1_balance)
#             # print("after_fiber1_balance:", after_fiber1_balance)
#             # assert after_fiber1_balance["ckb"]["offered_tlc_balance"] == 0
#             time.sleep(5)
#             self.send_payment(self.fiber1, self.fiber2, 1)
#
#     def test_bbb11(self):
#         self.get_fibers_balance_message()
#         self.send_payment(self.fiber2, self.fiber1, 1)
#         self.send_payment(self.fiber1, self.fiber2, 1)
#
#     def test_disconnect(self):
#         """
#         a-b-c-d-a
#         1. a-b  断开a-b
#         2. a-d,d-a  断开a-b，断开b-c 断开c-d
#         3. a-a,b-b,c-c,d-d 断开 a-b,b-c,c-d,a-d
#
#         # restart
#
#         Returns:
#         """
#         # self.start_new_fiber(self.generate_account(10000))
#         # self.start_new_fiber(self.generate_account(10000))
#         # self.open_channel(self.fibers[1], self.fibers[2], 1000 * 100000000, 1)
#         # self.open_channel(self.fibers[2], self.fibers[3], 1000 * 100000000, 1)
#         # self.open_channel(self.fibers[3], self.fibers[0], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[0], self.fibers[1], 1000 * 100000000, 1)
#
#         # a-b 压测 断开a-b
#         for j in range(2):
#             payment_hashs = []
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fiber1, self.fiber2, 1 * 100000000, False
#                 )
#                 payment_hashs.append(payment_hash)
#             self.fiber1.get_client().disconnect_peer(
#                 {"peer_id": self.fiber2.get_peer_id()}
#             )
#             time.sleep(10)
#             before_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             assert before_fiber1_balance["ckb"]["offered_tlc_balance"] > 0
#             self.fiber1.connect_peer(self.fiber2)
#             self.wait_fibers_pending_tlc_eq0(self.fiber1)
#             after_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             print("before_fiber1_balance:", before_fiber1_balance)
#             print("after_fiber1_balance:", after_fiber1_balance)
#             assert after_fiber1_balance["ckb"]["offered_tlc_balance"] == 0
#             self.send_payment(self.fiber1, self.fiber2, 1,True)
#
#         # # a-d,d-a 断开a-b，断开b-c 断开c-d
#         # for j in range(1):
#         #     payment0_hashs = []
#         #     payment3_hashs = []
#         #     for i in range(30):
#         #         payment_hash = self.send_payment(
#         #             self.fibers[0], self.fibers[3], 1 * 100000000, False
#         #         )
#         #         payment0_hashs.append(payment_hash)
#         #         payment_hash = self.send_payment(
#         #             self.fibers[3], self.fibers[0], 1 * 100000000, False
#         #         )
#         #         payment3_hashs.append(payment_hash)
#         #     self.fibers[0].get_client().disconnect_peer(
#         #         {"peer_id": self.fibers[1].get_peer_id()}
#         #     )
#         #     self.fibers[1].get_client().disconnect_peer(
#         #         {"peer_id": self.fibers[2].get_peer_id()}
#         #     )
#         #     self.fibers[2].get_client().disconnect_peer(
#         #         {"peer_id": self.fibers[3].get_peer_id()}
#         #     )
#         #     time.sleep(10)
#         #     self.fibers[0].connect_peer(self.fibers[1])
#         #     self.fibers[1].connect_peer(self.fibers[2])
#         #     self.fibers[2].connect_peer(self.fibers[3])
#         #     for fiber in self.fibers:
#         #         self.wait_fibers_pending_tlc_eq0(fiber)
#         #     self.send_payment(self.fiber1, self.fiber1, 1)
#         # # a-a 断开 a-d a-b
#         # for j in range(1):
#         #     payment0_hashs = []
#         #     payment1_hashs = []
#         #     payment2_hashs = []
#         #     payment3_hashs = []
#         #
#         #     for i in range(30):
#         #         payment_hash = self.send_payment(
#         #             self.fibers[0], self.fibers[0], 1 * 100000000, False
#         #         )
#         #         payment0_hashs.append(payment_hash)
#         #         payment_hash = self.send_payment(
#         #             self.fibers[1], self.fibers[1], 1 * 100000000, False
#         #         )
#         #         payment1_hashs.append(payment_hash)
#         #         payment_hash = self.send_payment(
#         #             self.fibers[2], self.fibers[2], 1 * 100000000, False
#         #         )
#         #         payment2_hashs.append(payment_hash)
#         #         payment_hash = self.send_payment(
#         #             self.fibers[3], self.fibers[3], 1 * 100000000, False
#         #         )
#         #         payment3_hashs.append(payment_hash)
#         #
#         #     self.fibers[0].get_client().disconnect_peer(
#         #         {"peer_id": self.fibers[1].get_peer_id()}
#         #     )
#         #     self.fibers[1].get_client().disconnect_peer(
#         #         {"peer_id": self.fibers[2].get_peer_id()}
#         #     )
#         #     self.fibers[2].get_client().disconnect_peer(
#         #         {"peer_id": self.fibers[3].get_peer_id()}
#         #     )
#         #     self.fibers[3].get_client().disconnect_peer(
#         #         {"peer_id": self.fibers[0].get_peer_id()}
#         #     )
#         #
#         #     time.sleep(10)
#         #     self.fibers[0].connect_peer(self.fibers[1])
#         #     self.fibers[1].connect_peer(self.fibers[2])
#         #     self.fibers[2].connect_peer(self.fibers[3])
#         #     self.fibers[3].connect_peer(self.fibers[0])
#         #     for fiber in self.fibers:
#         #         self.wait_fibers_pending_tlc_eq0(fiber)
#
#
#     def test_restart(self):
#         """
#         a-b-c-d-a
#         1. a-b  断开a-b
#         2. a-d,d-a  断开a-b，断开b-c 断开c-d
#         3. a-a,b-b,c-c,d-d 断开 a-b,b-c,c-d,a-d
#
#
#         Returns:
#         """
#         self.start_new_fiber(self.generate_account(10000))
#         self.start_new_fiber(self.generate_account(10000))
#         self.open_channel(self.fibers[1], self.fibers[2], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[2], self.fibers[3], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[3], self.fibers[0], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[0], self.fibers[1], 1000 * 100000000, 1)
#
#         # a-b 压测 断开a-b
#         for j in range(1):
#             payment_hashs = []
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fiber1, self.fiber2, 1 * 100000000, False
#                 )
#                 payment_hashs.append(payment_hash)
#             # self.fiber1.get_client().disconnect_peer({"peer_id": self.fiber2.get_peer_id()})
#             self.fiber1.stop()
#             self.fiber2.stop()
#             self.fiber1.start()
#             time.sleep(10)
#             before_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             assert before_fiber1_balance["ckb"]["offered_tlc_balance"] > 0
#             self.fiber2.start()
#
#             # for payment_hash in payment_hashs:
#             #     self.wait_payment_finished(self.fiber1, payment_hash)
#             self.wait_fibers_pending_tlc_eq0(self.fiber1)
#             after_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             print("before_fiber1_balance:", before_fiber1_balance)
#             print("after_fiber1_balance:", after_fiber1_balance)
#             # assert after_fiber1_balance["ckb"]["offered_tlc_balance"] == 0
#         self.send_payment(self.fiber1, self.fiber1, 1)
#
#         # a-d,d-a 断开a-b，断开b-c 断开c-d
#         for j in range(1):
#             payment0_hashs = []
#             payment3_hashs = []
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fibers[0], self.fibers[3], 1 * 100000000, False
#                 )
#                 payment0_hashs.append(payment_hash)
#                 payment_hash = self.send_payment(
#                     self.fibers[3], self.fibers[0], 1 * 100000000, False
#                 )
#                 payment3_hashs.append(payment_hash)
#             for fiber in self.fibers:
#                 fiber.stop()
#             for fiber in self.fibers:
#                 fiber.start()
#
#             for fiber in self.fibers:
#                 self.wait_fibers_pending_tlc_eq0(fiber)
#         self.send_payment(self.fiber1, self.fiber1, 1)
#
#         # a-a 断开 a-d a-b
#         for j in range(1):
#             payment0_hashs = []
#             payment1_hashs = []
#             payment2_hashs = []
#             payment3_hashs = []
#
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fibers[0], self.fibers[0], 1 * 100000000, False
#                 )
#                 payment0_hashs.append(payment_hash)
#                 payment_hash = self.send_payment(
#                     self.fibers[1], self.fibers[1], 1 * 100000000, False
#                 )
#                 payment1_hashs.append(payment_hash)
#                 payment_hash = self.send_payment(
#                     self.fibers[2], self.fibers[2], 1 * 100000000, False
#                 )
#                 payment2_hashs.append(payment_hash)
#                 payment_hash = self.send_payment(
#                     self.fibers[3], self.fibers[3], 1 * 100000000, False
#                 )
#                 payment3_hashs.append(payment_hash)
#
#             for fiber in self.fibers:
#                 fiber.stop()
#
#             for fiber in self.fibers:
#                 fiber.start()
#
#             for fiber in self.fibers:
#                 self.wait_fibers_pending_tlc_eq0(fiber)
#
#
#     def test_force_restart(self):
#         """
#         a-b-c-d-a
#         1. a-b  断开a-b
#         2. a-d,d-a  断开a-b，断开b-c 断开c-d
#         3. a-a,b-b,c-c,d-d 断开 a-b,b-c,c-d,a-d
#
#
#         Returns:
#         """
#         self.start_new_fiber(self.generate_account(10000))
#         self.start_new_fiber(self.generate_account(10000))
#         self.open_channel(self.fibers[1], self.fibers[2], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[2], self.fibers[3], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[3], self.fibers[0], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[0], self.fibers[1], 1000 * 100000000, 1)
#
#         # a-b 压测 断开a-b
#         for j in range(3):
#             payment_hashs = []
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fiber1, self.fiber2, 1 * 100000000, False
#                 )
#                 payment_hashs.append(payment_hash)
#             # self.fiber1.get_client().disconnect_peer({"peer_id": self.fiber2.get_peer_id()})
#             self.fiber1.force_stop()
#             self.fiber2.force_stop()
#             self.fiber1.start()
#             time.sleep(10)
#             before_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             assert before_fiber1_balance["ckb"]["offered_tlc_balance"] > 0
#             self.fiber2.start()
#
#             # for payment_hash in payment_hashs:
#             #     self.wait_payment_finished(self.fiber1, payment_hash)
#             self.wait_fibers_pending_tlc_eq0(self.fiber1)
#             after_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             print("before_fiber1_balance:", before_fiber1_balance)
#             print("after_fiber1_balance:", after_fiber1_balance)
#             # assert after_fiber1_balance["ckb"]["offered_tlc_balance"] == 0
#             self.send_payment(self.fiber1, self.fiber1, 1)
#
#         # a-d,d-a 断开a-b，断开b-c 断开c-d
#         for j in range(1):
#             payment0_hashs = []
#             payment3_hashs = []
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fibers[0], self.fibers[3], 1 * 100000000, False
#                 )
#                 payment0_hashs.append(payment_hash)
#                 payment_hash = self.send_payment(
#                     self.fibers[3], self.fibers[0], 1 * 100000000, False
#                 )
#                 payment3_hashs.append(payment_hash)
#             for fiber in self.fibers:
#                 fiber.stop()
#             for fiber in self.fibers:
#                 fiber.start()
#
#             for fiber in self.fibers:
#                 self.wait_fibers_pending_tlc_eq0(fiber)
#         self.send_payment(self.fiber1, self.fiber1, 1)
#
#         # # a-a 断开 a-d a-b
#         for j in range(1):
#             payment0_hashs = []
#             payment1_hashs = []
#             payment2_hashs = []
#             payment3_hashs = []
#
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fibers[0], self.fibers[0], 1 * 100000000, False
#                 )
#                 payment0_hashs.append(payment_hash)
#                 payment_hash = self.send_payment(
#                     self.fibers[1], self.fibers[1], 1 * 100000000, False
#                 )
#                 payment1_hashs.append(payment_hash)
#                 payment_hash = self.send_payment(
#                     self.fibers[2], self.fibers[2], 1 * 100000000, False
#                 )
#                 payment2_hashs.append(payment_hash)
#                 payment_hash = self.send_payment(
#                     self.fibers[3], self.fibers[3], 1 * 100000000, False
#                 )
#                 payment3_hashs.append(payment_hash)
#
#             for fiber in self.fibers:
#                 fiber.force_stop()
#
#             for fiber in self.fibers:
#                 fiber.start()
#
#             for fiber in self.fibers:
#                 self.wait_fibers_pending_tlc_eq0(fiber)
#
#
#     def test_mutil_path(self):
#         """
#         a-b-c-d
#         a-d
#         1. a-d  断开a-d，重连a-d 能够恢复
#         2. 压测 a-d 断开a-d，发一笔a-d 能够成功，继续压测a-d,断开 b-c，重连a-d，b-c 能够恢复
#         Returns:
#         """
#         self.start_new_fiber(self.generate_account(10000))
#         self.start_new_fiber(self.generate_account(10000))
#         self.open_channel(self.fibers[0], self.fibers[1], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[1], self.fibers[2], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[2], self.fibers[3], 1000 * 100000000, 1)
#         self.open_channel(self.fibers[0], self.fibers[3], 1000 * 100000000, 1)
#
#         #         1. a-d  断开a-d，重连a-d 能够恢复
#         for j in range(1):
#             payment_hashs = []
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fiber1, self.fibers[3], 1 * 100000000, False
#                 )
#                 payment_hashs.append(payment_hash)
#             self.fiber1.get_client().disconnect_peer(
#                 {"peer_id": self.fibers[3].get_peer_id()}
#             )
#             time.sleep(10)
#
#             before_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             assert before_fiber1_balance["ckb"]["offered_tlc_balance"] > 0
#             self.send_payment(self.fiber1, self.fibers[3], 1)
#             self.fiber1.connect_peer(self.fibers[3])
#             self.wait_fibers_pending_tlc_eq0(self.fiber1)
#             self.send_payment(self.fiber1, self.fibers[3], 1)
#
#         # 2. 压测 a-d 断开a-d，发一笔a-d 能够成功，继续压测a-d,断开 b-c，重连a-d，b-c 能够恢复
#         for j in range(1):
#             payment_hashs = []
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fiber1, self.fibers[3], 1 * 100000000, False
#                 )
#                 payment_hashs.append(payment_hash)
#             self.fiber1.get_client().disconnect_peer(
#                 {"peer_id": self.fibers[3].get_peer_id()}
#             )
#             time.sleep(10)
#
#             before_fiber1_balance = self.get_fiber_balance(self.fiber1)
#             assert before_fiber1_balance["ckb"]["offered_tlc_balance"] > 0
#             self.send_payment(self.fiber1, self.fibers[3], 1)
#
#             for i in range(30):
#                 payment_hash = self.send_payment(
#                     self.fiber1, self.fibers[3], 1 * 100000000, False
#                 )
#                 payment_hashs.append(payment_hash)
#             self.fiber2.get_client().disconnect_peer(
#                 {"peer_id": self.fibers[2].get_peer_id()}
#             )
#             time.sleep(10)
#             before_fiber2_balance = self.get_fiber_balance(self.fiber2)
#             assert before_fiber2_balance["ckb"]["offered_tlc_balance"] > 0
#             self.fiber1.connect_peer(self.fibers[3])
#             self.fiber2.connect_peer(self.fibers[2])
#             self.wait_fibers_pending_tlc_eq0(self.fiber1)
#             self.wait_fibers_pending_tlc_eq0(self.fiber2)
#             self.send_payment(self.fiber1, self.fibers[3], 1)
#
#
